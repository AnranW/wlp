%************************************************
\chapter{Background}\label{ch:background}
%************************************************


In 1739, Scottish philosopher David Hume questioned why we know that the sun will rise tomorrow, `` tho' 'tis plain we have no further assurance of these facts, than what experience affords us''~\cite{hume1896}. 
Hume's question about causality is daunting, yet most of us are not in crisis because we doubt if the sun rises tomorrow. 
The reason is probably that we believe in physics, astrology, and the rules and formulas that assure us the universe works in a certain way, hence the sun rises tomorrow. 
It is exactly the rules and formulas this thesis attempts to investigate, in the realm of computer programs, with which we are certain that the equivalent version of the sun in a program will rise tomorrow. 

Computer programs undoubtedly have melded into almost every aspect of human life. 
We want them to solve our problem efficiently, and correctly. 
Imagine being driven by an autonomous car. It it desirable that it delivers us to the correct destination, and never get stuck driving around a same block without making progress. 
Delivering the correct result and stopping eventually is called \define{total correctness}. 
Once we know that a program is totally correct, then we are sure that the sun rises tomorrow. 

To know ``for sure'', we could verify programs using formal methods. 
One famous method is \define{Hoare Triples}~\cite{Hoare69}. 
A Hoare Triple contains three parts: a precondition, a program, and a postcondition. 
They are written as such: \hoare{G}{C}{F}.
%%\footnote{Originally it was written as $F \{C\} G$, but now it is often written with brackets around conditions instead of the program.} 
It states that if the system is in a state that satisfies the precondition, then the state after the execution of the program will satisfy the postcondition, provided that the program terminates.
Hoare Triples is elegant in that once we have appropriate preconditions, it works well syntactically and sequentially. 
But with Hoare Triples in its original form, we know the program is correct, but we are not sure of its termination. 
This is called \define{partial correctness}. 

To prove a program totally correct, Dijkstra presented the \define{weakest precondition transformer}~\cite{dijkstra75} (wp): starting with a postcondition, it works backwards and calculates what the precondition can be that guarantees both correctness and termination. 
While in Hoare Triples, the precondition is a \imptt{sufficient} condition where the program will be correct in that the final state will satisfy the desired postcondition, with wp we obtain a \imptt{necessary and sufficient} precondition. 

Since then, a plethora of research projects blossomed and yielded fruitful results. 
This thesis aims to follow the steps of the predecessors and investigate \define{weakest liberal precondition transformer}~\cite{dijkstra90} (wlp), which gives preconditions that are necessary and sufficient so that the program either terminates correctly, or never terminates. 

We first introduce Hoare Triples, wp transformer, and wlp transformer, using \define{Guarded Command Language}~\cite{dijkstra75} to present programs in \autoref{ch:Preliminaries}. 
We also explain their connections and differences. 

Then we proceed to \autoref{ch:system} [fill in content of this chapter] %TODO







% wp is concerned with total correctness and is related to Hoare Triples by an implication: 
% \footnote{Here $wp.C.F$ is a function written in lambda-calculus style, it can be seen now as a function $wp(C,F)$. This form of writing proves to be simple and elegant in the upcoming sections.}
% \[\forall G.\ G\implies wp.C.F: \{G\} C \{F\}\]
% This connection not only tells us that 
% \begin{itemize}
%     \item[-] given $wp.C.F$, any predicate $G$ that implies it can be the precondition of a valid Hoare Triple: $\{G\} C \{F\}$; 
% \end{itemize}
% it also shows when Hoare Triple will guarantee total correctness: 
% \begin{itemize}
%     \item[-] given a valid Hoare Triple $\{G\} C \{F\}$, if its precondition $G$ implies $wp.C.F$, then $\{G\} C \{F\}$ is valid for total correctness. 
% \end{itemize}

% Sometimes, however, we deem nontermination a good behaviour, and proving partial correctness suffices. 
% The \define{weakest liberal precondition} transformer \cite{Dijkstra90} can be used in such occasions: 
% if the system is in a state satisfying $wlp.C.F$, then either $F$ is reachable after the termination of $C$, or $C$ does not terminate.
% wlp directly relates to Hoare Triples via an implication: 
% \[\forall G.\ G\implies wlp.C.F: \{G\} C \{F\}\]
% $G$ is then called the \define{sufficient liberal precondition}, and finding it means we can prove the absense of errors in the program (if it terminates). 
% In contrast, the \define{necessary liberal precondition} $G$ (where $ wlp.C.F\implies G$) tells us that the system will not satisfy the postcondition $F$, once $G$ is violated. 
% Cousot et al. studied the matter from a practical perspective~\cite{Cousot13}, they proposed inference tools and experimented in industrial codes.
% In this thesis, we aim to research this matter further with a more theoretical view. 
% We would like to propose a proof system and prove its soundness and completeness similar as in \cite{Vries11}, but using Dijkstra's guarded command language (GCL)~\cite{Dijkstra75}. 

% Instead of the usual qualitative reasoning using logical predicates, we would like to study in a quantitive setting using functions that represent quantities such as expectations of program variables. 
% While predicates map program states to true or false, functions map program states to $R\infty$, real numbers extended with (negative) infinity. 
% In this setting, not only are infinities clear indication for nontermination, the transformers can also express more such as flow of quantitive information~\cite{Zhang22}.


\todo{Decide on all the colors in the end. }


