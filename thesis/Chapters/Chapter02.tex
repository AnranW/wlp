%*****************************************
\chapter{Preliminaries}\label{ch:Preliminaries}
%*****************************************
%\setcounter{figure}{10}
% \NoCaseChange{Homo Sapiens}
\section{Guarded Command Language}
We use Dijkstra's (non-deterministic) guarded command language (nGCL)~\cite{Dijkstra1975} to conceptualize a computer program and to include non-determinism.
For better understanding, we use an equivalent form~\cite{Zhang2022} of nGCL that is similar to modern pseudo-code:
$$C\ ::=\ \  x:= e \ \ \mid\ \  C;C \ \ \mid\ \  \{C\}
 \square \{C\} \ \ \mid\ \
if\ (\varphi)\ \{C\}\ else\ \{C\} \ \ \mid\ \  while\ (\varphi)\ \{C\}$$

\section{Hoare Triple}
A Hoare Triple is a triple $ \{G\} C \{F\}$ where $G$ and $F$ are logical predicates, and C is a program.
$G$ is called a \textit{precondition}, $F$ a \textit{postcondition}.
This triple reads, ``if $G$ is satisfied before the execution of $C$, then if $C$ terminates, $F$ is satisfied after the execution of $C$''.

\section{Quantity}
Let $\Sigma$ be the set of all program states, then the set of quantities is defined by
\[A=\{f\mid f:\Sigma
\to
\Rinf
\}\]
With the ordering
\[f\preceq g \text{ iff } \forall \sigma \in \Sigma: f(\sigma)\leq g(\sigma)\]
as well as join $\join$ and meet $\meet$
\[f\join g = \lambda \sigma.min\{f(\sigma), g(\sigma)\}; \ \ \  f\meet g = \lambda \sigma.max\{f(\sigma), g(\sigma) \}\]
we can define a complete lattice $\langle A, \preceq\rangle$.
Note that all subsets in a complete lattice have supremum and infimum.

Informally, $f\preceq g$ is analogous to $F\implies G$ for predicates, $\join$ ($\meet$) is analogous to $\wedge$ ($\vee$).

\section{Weakest (Liberal) Prequantity}
Let $\bkt{C}
(\sigma)$ be the set of all
\textbf{reachable} states by program
$C$ from initial state $\sigma$, $f$ a \textit{postquantity}.
Let $\bigmeet S$ denote the supremum of set $S$, then:
\[wp.C.f.\sigma = \underset{\tau\in\bkt{C}
(\sigma)}
{\bigmeet}
f(\tau)\]

As the name suggests, $wp.C.f.\sigma$ gives the ``weakest'', i.e. supremum, prequantity given post quantity $f$.
Given the program, postquantity, initial state, the wp transformer gives the ``biggest'' element of all postquantities at all reachable final states.
Since $f\preceq g$ means $g$ is weaker than $f$, the biggest quantity is the weakest.
Informally, fixing an initial state, whether a prequantity is valid for the weakest prequantity depends on whether the postquantity is valid for at least one of the final states.
\begin{comment}
Note that supremum can be not an element of the infinite set.
\end{comment}

The weakest liberal prequantity transformer is defined with the infimum:
\[wlp.C.f.\sigma = \underset{\tau\in\bkt C(\sigma)}{\bigjoin} f(\tau)\]

\section{Necessary and Sufficient Conditions}
We can now use some implications to define correctness or incorrectness as shown in \tab{impl}.
\begin{table}\centering
    \begin{tabular}{cc}
      \textbf{implication}&\textbf{defines}    \\ \hline
      $G\implies wp(C,F)$&   total correctness   \\
      $G\implies wlp(C,F)$&  partial correctness\\
      $wp(C,F)\implies G$&  partial incorrectness\\
      $wlp(C,F)\implies G$&  ???\\
    \end{tabular}
    \caption{implications using wp and wlp\cite{Zhang2022}}
    \label{tab:impl}
\end{table}

We are interested in the last implication labeled with ???, where $G$ is called the \textit{necessary liberal precondition}, in a sense that
\begin{itemize}
    \item [-] all preconditions that lead to non-termination of $C$ imply $G$,
    \item [-] a preconditions that do not imply $G$ leads to a postcondition that does not imply $F$.
\end{itemize}
Our goal is to study this implication and its connection to correctness/incorrectness.



%*****************************************
%*****************************************
%*****************************************
%*****************************************
%*****************************************
