@article{hoare69,
  title={An axiomatic basis for computer programming},
  author={Hoare, Charles Antony Richard},
  journal={Communications of the ACM},
  volume={12},
  number={10},
  pages={576--580},
  year={1969},
  publisher={ACM New York, NY, USA}
}
@book{dijkstra90,
  title = {Predicate {{Calculus}} and {{Program Semantics}}},
  author = {Dijkstra, Edsger W. and Scholten, Carel S.},
  year = {1990},
  publisher = {Springer},
  address = {New York, NY},
  doi = {10.1007/978-1-4612-3228-5},
  isbn = {978-1-4612-7924-2 978-1-4612-3228-5},
  keywords = {formal specification,program semantics,programming language,semantics},
  file = {/Users/anranwang/Zotero/storage/NBH3BB7P/dijkstra-predicate calculus.pdf}
}

@article{dijkstra75,
  title={Guarded commands, nondeterminacy and formal derivation of programs},
  author={Dijkstra, Edsger W.},
  journal={Communications of the ACM},
  volume={18},
  number={8},
  pages={453--457},
  year={1975},
  publisher={ACM New York, NY, USA}
}
@article{zhang22,
  title={Quantitative Strongest Post},
  author={Zhang, Linpeng and Kaminski, Benjamin},
  journal={arXiv preprint arXiv:2202.06765},
  year={2022}
}
@inproceedings{cousot13,
  title={Automatic inference of necessary preconditions},
  author={Cousot, Patrick and Cousot, Radhia and F{\"a}hndrich, Manuel and Logozzo, Francesco},
  booktitle={International Workshop on Verification, Model Checking, and Abstract Interpretation},
  pages={128--148},
  year={2013},
  organization={Springer}
}
@inproceedings{vries11,
  title={Reverse hoare logic},
  author={Vries, Edsko de and Koutavas, Vasileios},
  booktitle={International Conference on Software Engineering and Formal Methods},
  pages={155--171},
  year={2011},
  organization={Springer}
}
@article{apt81,
author = {Apt, Krzysztof R.},
title = {Ten Years of Hoare's Logic: A Survey—Part I},
year = {1981},
issue_date = {Oct. 1981},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {4},
issn = {0164-0925},
doi = {10.1145/357146.357150},
journal = {ACM Trans. Program. Lang. Syst.},
month = {10},
pages = {431–483},
numpages = {53}
}
@phdthesis{kaminski19,
  title={Advanced weakest precondition calculi for probabilistic programs},
  author={Kaminski, Benjamin Lucien},
  year={2019},
  school={RWTH Aachen University}
}
@article{manna74,
  title={Axiomatic approach to total correctness of programs},
  author={Manna, Zohar and Pnueli, Amir},
  journal={Acta Informatica},
  volume={3},
  pages={243--263},
  year={1974},
  publisher={Springer}
}
@article{floyd93,
  title={Assigning meanings to programs},
  author={Floyd, Robert W.},
  journal={Program Verification: Fundamental Issues in Computer Science},
  pages={65--81},
  year={1993},
  publisher={Springer}
}
@article{mccarthy93,
  title={Towards a mathematical science of computation},
  author={McCarthy, John},
  journal={Program Verification: Fundamental Issues in Computer Science},
  pages={35--56},
  year={1993},
  publisher={Springer}
}
@book{hume1896,
  title={A treatise of human nature},
  author={Hume, David},
  year={1896},
  publisher={Clarendon Press}
}
@book{nipkow2014,
  title={Concrete semantics: with Isabelle/HOL},
  author={Nipkow, Tobias and Klein, Gerwin},
  year={2014},
  publisher={Springer}
}
@article{peterson1981,
  title={Myths about the mutual exclusion problem},
  author={Peterson, Gary L.},
  journal={Information Processing Letters},
  volume={12},
  pages={115--116},
  year={1981}
}
@InProceedings{myreen07,
author="Myreen, Magnus O.
and Gordon, Michael J. C.",
editor="Grumberg, Orna
and Huth, Michael",
title="Hoare Logic for Realistically Modelled Machine Code",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2007",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="568--582",
abstract="This paper presents a mechanised Hoare-style programming logic framework for assembly level programs. The framework has been designed to fit on top of operational semantics of realistically modelled machine code. Many ad hoc restrictions and features present in real machine-code are handled, including finite memory, data and code in the same memory space, the behavior of status registers and hazards of corrupting special purpose registers (e.g. the program counter, procedure return register and stack pointer). Despite accurately modeling such low level details, the approach yields concise specifications for machine-code programs without using common simplifying assumptions (like an unbounded state space). The framework is based on a flexible state representation in which functional and resource usage specifications are written in a style inspired by separation logic. The presented work has been formalised in higher-order logic, mechanised in the HOL4 system and is currently being used to verify ARM machine-code implementations of arithmetic and cryptographic operations.",
isbn="978-3-540-71209-1"
}
@inproceedings{zhou19,
author = {Zhou, Li and Yu, Nengkun and Ying, Mingsheng},
title = {An applied quantum Hoare logic},
year = {2019},
isbn = {9781450367127},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/3314221.3314584},
abstract = {We derive a variant of quantum Hoare logic (QHL), called applied quantum Hoare logic (aQHL for short), by: 1. restricting QHL to a special class of preconditions and postconditions, namely projections, which can significantly simplify verification of quantum programs and are much more convenient when used in debugging and testing; and 2. adding several rules for reasoning about robustness of quantum programs, i.e. error bounds of outputs. The effectiveness of aQHL is shown by its applications to verify two sophisticated quantum algorithms: HHL (Harrow-Hassidim-Lloyd) for solving systems of linear equations and qPCA (quantum Principal Component Analysis).},
booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {1149–1162},
numpages = {14},
keywords = {robustness, projections, programming languages, Quantum computation, Hoare logic},
location = {Phoenix, AZ, USA},
series = {PLDI 2019}
}
@incollection{gordon2010ForwardHoare,
  title = {Forward with {{Hoare}}},
  booktitle = {Reflections on the {{Work}} of {{C}}.{{A}}.{{R}}. {{Hoare}}},
  author = {Gordon, Mike and Collavizza, H{\'e}l{\`e}ne},
  editor = {Roscoe, A.W. and Jones, Cliff B. and Wood, Kenneth R.},
  year = {2010},
  pages = {101--121},
  publisher = {Springer London},
  address = {London},
  doi = {10.1007/978-1-84882-912-1_5},
  abstract = {Hoare's celebrated paper entitled ``An Axiomatic Basis for Computer Programming'' appeared in 1969, so the Hoare formula PfSgQ is now 40 years old! That paper introduced Hoare Logic, which is still the basis for program verification today, but is now mechanised inside sophisticated verification systems. We aim here to give an accessible introduction to methods for proving Hoare formulae based both on the forward computation of postconditions and on the backward computation of preconditions. Although precondition methods are better known, computing postconditions provides a verification framework that encompasses methods ranging from symbolic execution to full deductive proof of correctness.},
  isbn = {978-1-84882-911-4 978-1-84882-912-1},
  langid = {english},
  file = {/Users/anranwang/Zotero/storage/NCKHZ596/Gordon and Collavizza - 2010 - Forward with Hoare.pdf}
}
@article{hooman1994extending,
  title={Extending Hoare logic to real-time},
  author={Hooman, Jozef},
  journal={Formal Aspects of Computing},
  volume={6},
  pages={801--825},
  year={1994},
  publisher={Springer}
}
@inproceedings{kaminski2016weakest,
  title={Weakest precondition reasoning for expected run--times of probabilistic programs},
  author={Kaminski, Benjamin Lucien and Katoen, Joost-Pieter and Matheja, Christoph and Olmedo, Federico},
  booktitle={Programming Languages and Systems: 25th European Symposium on Programming, ESOP 2016, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2016, Eindhoven, The Netherlands, April 2--8, 2016, Proceedings 25},
  pages={364--389},
  year={2016},
  organization={Springer}
}
@inproceedings{liu22,
author = {Liu, Junyi and Zhou, Li and Barthe, Gilles and Ying, Mingsheng},
title = {Quantum Weakest Preconditions for Reasoning about Expected Runtimes of Quantum Programs},
year = {2022},
isbn = {9781450393515},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/3531130.3533327},
abstract = {We study expected runtimes for quantum programs. Inspired by recent work on probabilistic programs, we first define expected runtime as a generalisation of quantum weakest precondition. Then, we show that the expected runtime of a quantum program can be represented as the expectation of an observable (in physics). A method for computing the expected runtimes of quantum programs in finite-dimensional state spaces is developed. Several examples are provided as applications of this method, including computing the expected runtime of quantum Bernoulli Factory – a quantum algorithm for generating random numbers. In particular, using our new method, an open problem of computing the expected runtime of quantum random walks introduced by Ambainis et al. (STOC 2001) is solved.},
booktitle = {Proceedings of the 37th Annual ACM/IEEE Symposium on Logic in Computer Science},
articleno = {4},
numpages = {13},
keywords = {termination, quantum weakest precondition, quantum random walk, physical observable, expected runtime, Quantum programming},
location = {Haifa, Israel},
series = {LICS '22}
}
@article{boreale20,
title = {Complete algorithms for algebraic strongest postconditions and weakest preconditions in polynomial odes},
journal = {Science of Computer Programming},
volume = {193},
pages = {102441},
year = {2020},
issn = {0167-6423},
doi = {https://doi.org/10.1016/j.scico.2020.102441},
author = {Michele Boreale},
keywords = {Ordinary differential equations, Postconditions, Preconditions, Invariants, Gröbner bases},
abstract = {A system of polynomial ordinary differential equations (odes) is specified via a vector of multivariate polynomials, or vector field, F. A safety assertion ψ⟶[F]ϕ means that the trajectory of the system will lie in a subset ϕ (the postcondition) of the state-space, whenever the initial state belongs to a subset ψ (the precondition). We consider the case when ϕ and ψ are algebraic varieties, that is, zero sets of polynomials. In particular, polynomials specifying the postcondition can be seen as a system's conservation laws implied by ψ. Checking the validity of algebraic safety assertions is a fundamental problem in, for instance, hybrid systems. We consider a generalized version of this problem, and offer an algorithm that, given a user specified polynomial set P and an algebraic precondition ψ, finds the largest subset of polynomials in P implied by ψ (relativized strongest postcondition). Under certain assumptions on ϕ, this algorithm can also be used to find the largest algebraic invariant included in ϕ and the weakest algebraic precondition for ϕ. Applications to continuous semialgebraic systems are also considered. The effectiveness of the proposed algorithm is demonstrated on several case studies from the literature.}
}
@article{ohearn2020IncorrectnessLogic,
  title = {Incorrectness Logic},
  author = {O'Hearn, Peter W.},
  year = {2020},
  month = jan,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {4},
  number = {POPL},
  pages = {1--32},
  issn = {2475-1421},
  doi = {10.1145/3371078},
  abstract = {PETER W. O'HEARN, Facebook and University College London, UK 10 Program correctness and incorrectness are two sides of the same coin. As a programmer, even if you would like to have correctness, you might find yourself spending most of your time reasoning about incorrectness. This includes informal reasoning that people do while looking at or thinking about their code, as well as that supported by automated testing and static analysis tools. This paper describes a simple logic for program incorrectness which is, in a sense, the other side of the coin to Hoare's logic of correctness. CCS Concepts: {$\cdot$} Theory of computation {$\rightarrow$} Programming logic.},
  langid = {english},
  file = {/Users/anranwang/Zotero/storage/QFTM7737/O'Hearn - 2020 - Incorrectness logic.pdf}
}
@inproceedings{klein09,
author = {Klein, Gerwin and Elphinstone, Kevin and Heiser, Gernot and Andronick, June and Cock, David and Derrin, Philip and Elkaduwe, Dhammika and Engelhardt, Kai and Kolanski, Rafal and Norrish, Michael and Sewell, Thomas and Tuch, Harvey and Winwood, Simon},
title = {seL4: formal verification of an OS kernel},
year = {2009},
isbn = {9781605587523},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/1629575.1629596},
abstract = {Complete formal verification is the only known way to guarantee that a system is free of programming errors.We present our experience in performing the formal, machine-checked verification of the seL4 microkernel from an abstract specification down to its C implementation. We assume correctness of compiler, assembly code, and hardware, and we used a unique design approach that fuses formal and operating systems techniques. To our knowledge, this is the first formal proof of functional correctness of a complete, general-purpose operating-system kernel. Functional correctness means here that the implementation always strictly follows our high-level abstract specification of kernel behaviour. This encompasses traditional design and implementation safety properties such as the kernel will never crash, and it will never perform an unsafe operation. It also proves much more: we can predict precisely how the kernel will behave in every possible situation.seL4, a third-generation microkernel of L4 provenance, comprises 8,700 lines of C code and 600 lines of assembler. Its performance is comparable to other high-performance L4 kernels.},
booktitle = {Proceedings of the ACM SIGOPS 22nd Symposium on Operating Systems Principles},
pages = {207–220},
numpages = {14},
keywords = {sel4, microkernel, l4, isabelle/hol},
location = {Big Sky, Montana, USA},
series = {SOSP '09}
}
@book{nipkow2002isabelle,
  title={Isabelle/HOL: a proof assistant for higher-order logic},
  author={Nipkow, Tobias and Wenzel, Markus and Paulson, Lawrence C},
  year={2002},
  publisher={Springer}
}
@book{dijkstra76,
  title = {A Discipline of Programming},
  author = {Dijkstra, Edsger W.},
  year = {1976},
  series = {Prentice-{{Hall}} Series in Automatic Computation},
  publisher = {Prentice-Hall},
  address = {Englewood Cliffs, N.J},
  isbn = {978-0-13-215871-8},
  langid = {english},
  lccn = {QA76.6 .D54},
  keywords = {Computer programming},
  file = {/Users/anranwang/Zotero/storage/568D7XYT/Dijkstra - 1976 - A discipline of programming.pdf}
}
@book{hawkes2012,
  title = {The {{Songs}} of the {{South}}: {{An Anthology}} of {{Ancient Chinese Poems}} by {{Qu Yuan}} and {{Other Poets}}},
  shorttitle = {The {{Songs}} of the {{South}}},
  author = {Hawkes, David and Yuan, Qu and Various},
  year = {2012},
  month = jan,
  edition = {Reissue edition},
  publisher = {Penguin Classics},
  address = {Harmondsworth},
  abstract = {Masterworks of early Chinese poetryDating from the second century AD, this anthology is the second- oldest collection of Chinese poems in existence. The poems, originating from the state of Chu and rooted in Shamanism, are grouped under seventeen titles and contain all that we know of Chinese poetry's ancient beginnings. The earliest poems were composed in the fourth century BC, and almost half of them are traditionally ascribed to Qu Yuan. In his introduction to this edition, David Hawkes provides a fascinating discussion of the history of these poems and their context, styles, and themes.For more than seventy years, Penguin has been the leading publisher of classic literature in the English-speaking world. With more than 1,700~titles, Penguin Classics represents a global bookshelf of the best works throughout history and across genres and disciplines. Readers trust the~series to provide authoritative texts enhanced by introductions and notes by distinguished scholars and contemporary authors, as well as up-to-date~translations by award-winning translators.},
  isbn = {978-0-14-044375-2},
  langid = {english}
}
@book{li2011NonlinearMathematicsUncertainty,
  title = {Nonlinear {{Mathematics}} for {{Uncertainty}} and Its {{Applications}}},
  editor = {Li, Shoumei and Wang, Xia and Okazaki, Yoshiaki and Kawabe, Jun and Murofushi, Toshiaki and Guan, Li and Kacprzyk, Janusz},
  year = {2011},
  series = {Advances in {{Intelligent}} and {{Soft Computing}}},
  volume = {100},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-22833-9},
  copyright = {https://www.springernature.com/gp/researchers/text-and-data-mining},
  isbn = {978-3-642-22832-2 978-3-642-22833-9},
  langid = {english},
  file = {/Users/anranwang/Zotero/storage/MPGPVM8D/Li et al. - 2011 - Nonlinear Mathematics for Uncertainty and its Appl.pdf}
}
@misc{wulandari2020VerifyingGraphPrograms,
  title = {Verifying {{Graph Programs}} with {{First-Order Logic}} ({{Extended Version}})},
  author = {Wulandari, Gia and Plump, Detlef},
  year = {2020},
  month = nov,
  number = {arXiv:2010.14549},
  eprint = {2010.14549},
  primaryclass = {cs},
  publisher = {arXiv},
  abstract = {We consider Hoare-style verification for the graph programming language GP 2. In previous work, graph properties were specified by so-called E-conditions which extend nested graph conditions. However, this type of assertions is not easy to comprehend by programmers that are used to formal specifications in standard first-order logic. In this paper, we present an approach to verify GP 2 programs with a standard first-order logic. We show how to construct a strongest liberal postcondition with respect to a rule schema and a precondition. We then extend this construction to obtain strongest liberal postconditions for arbitrary loop-free programs. Compared with previous work, this allows to reason about a vastly generalised class of graph programs. In particular, many programs with nested loops can be verified with the new calculus.},
  archiveprefix = {arxiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/Users/anranwang/Zotero/storage/5PBFAFLC/Wulandari and Plump - 2020 - Verifying Graph Programs with First-Order Logic (E.pdf}
}
@incollection{nipkow2002HoareLogicsIsabelle,
  title = {Hoare {{Logics}} in {{Isabelle}}/{{HOL}}},
  booktitle = {Proof and {{System-Reliability}}},
  author = {Nipkow, Tobias},
  editor = {Schwichtenberg, Helmut and Steinbr{\"u}ggen, Ralf},
  year = {2002},
  pages = {341--367},
  publisher = {Springer Netherlands},
  address = {Dordrecht},
  doi = {10.1007/978-94-010-0413-8_11},
  abstract = {This paper describes Hoare logics for a number of imperative language constructs, from while-loops via exceptions to mutually recursive procedures. Both partial and total correctness are treated. In particular a proof system for total correctness of recursive procedures in the presence of unbounded nondeterminism is presented. All systems are formalized and shown to be sound and complete in the theorem prover Isabelle/HOL.},
  isbn = {978-1-4020-0608-1 978-94-010-0413-8},
  langid = {english},
  file = {/Users/anranwang/Zotero/storage/2F8P5YA4/Nipkow - 2002 - Hoare Logics in IsabelleHOL.pdf}
}
@article{lukkien1994OperationalSemanticsGeneralized,
  title = {Operational Semantics and Generalized Weakest Preconditions},
  author = {Lukkien, Johan J.},
  year = {1994},
  month = apr,
  journal = {Science of Computer Programming},
  volume = {22},
  number = {1-2},
  pages = {137--155},
  issn = {01676423},
  doi = {10.1016/0167-6423(94)90010-8},
  abstract = {Dijkstra and Scholten (1990) present an axiomatic semantics for Dijkstra's guarded command language through the notions of weakest precondition and weakest liberal precondition. The informal notion of a computation is used as a justification for the various definitions. In this paper we present an operational semantics in which the notion of a computation is made explicit. The novel contribution is a generalization of the notion of weakest precondition. This generalization supports reasoning about general properties of programs (i.e. not just termination in a certain state) and we introduce two properties in this way.},
  copyright = {https://www.elsevier.com/tdm/userlicense/1.0/},
  langid = {english},
  file = {/Users/anranwang/Zotero/storage/M64D7BKK/Lukkien - 1994 - Operational semantics and generalized weakest prec.pdf}
}
@article{leroy2009CoinductiveBigstepOperational,
  title = {Coinductive Big-Step Operational Semantics},
  author = {Leroy, Xavier and Grall, Herv{\'e}},
  year = {2009},
  month = feb,
  journal = {Information and Computation},
  volume = {207},
  number = {2},
  pages = {284--304},
  issn = {08905401},
  doi = {10.1016/j.ic.2007.12.004},
  abstract = {Using a call-by-value functional language as an example, this article illustrates the use of coinductive definitions and proofs in big-step operational semantics, enabling it to describe diverging evaluations in addition to terminating evaluations. We formalize the connections between the coinductive big-step semantics and the standard small-step semantics, proving that both semantics are equivalent. We then study the use of coinductive big-step semantics in proofs of type soundness and proofs of semantic preservation for compilers. A methodological originality of this paper is that all results have been proved using the Coq proof assistant. We explain the proof-theoretic presentation of coinductive definitions and proofs offered by Coq, and show that it facilitates the discovery and the presentation of the results.},
  copyright = {https://www.elsevier.com/tdm/userlicense/1.0/},
  langid = {english},
  file = {/Users/anranwang/Zotero/storage/M345UTQZ/Leroy and Grall - 2009 - Coinductive big-step operational semantics.pdf}
}
@incollection{nakata2009TraceBasedCoinductiveOperational,
  title = {Trace-{{Based Coinductive Operational Semantics}} for {{While}}},
  booktitle = {Theorem {{Proving}} in {{Higher Order Logics}}},
  author = {Nakata, Keiko and Uustalu, Tarmo},
  editor = {Berghofer, Stefan and Nipkow, Tobias and Urban, Christian and Wenzel, Makarius},
  year = {2009},
  volume = {5674},
  pages = {375--390},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-03359-9_26},
  abstract = {We present four coinductive operational semantics for the While language accounting for both terminating and non-terminating program runs: big-step and small-step relational semantics and big-step and small-step functional semantics. The semantics employ traces (possibly infinite sequences of states) to record the states that program runs go through. The relational semantics relate statement-state pairs to traces, whereas the functional semantics return traces for statement-state pairs. All four semantics are equivalent. We formalize the semantics and their equivalence proofs in the constructive setting of Coq.},
  isbn = {978-3-642-03358-2 978-3-642-03359-9},
  langid = {english},
  file = {/Users/anranwang/Zotero/storage/FY3AJTRR/Nakata and Uustalu - 2009 - Trace-Based Coinductive Operational Semantics for .pdf}
}
@misc{zhang22-full,
      title={Quantitative Strongest Post}, 
      author={Linpeng Zhang and Benjamin Lucien Kaminski},
      year={2022},
      eprint={2202.06765},
      archivePrefix={arXiv},
      primaryClass={cs.LO}
}
@article{cardone2006history,
  title={History of lambda-calculus and combinatory logic},
  author={Cardone, Felice and Hindley, J Roger},
  journal={Handbook of the History of Logic},
  volume={5},
  pages={723--817},
  year={2006},
  publisher={Citeseer}
}