\documentclass[adraft,hidelinks]{eptcs}
\usepackage{controlSequences}   % control sequences
\usepackage{comment}
%\setlength{\marginparwidth}{2cm} %to use todonotes package, delete if no todos
%\usepackage{todonotes}
% \usepackage{underscore}
% \usepackage{latexsym}
% \usepackage{wrapfig}
% \usepackage{marvosym}
%\usepackage{color}
% \usepackage{graphicx}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{stmaryrd}
% \usepackage{multicol}

% choose either one
% \usepackage{enumitem}
% \usepackage[shortlabels]{enumitem}

%  \setlist[enumerate, 1]{(1)}
% \usepackage{framed}
\usepackage[utf8]{inputenc}
%\definecolor{shadecolor}{rgb}{1,0.5,0.5}

\begin{document}

\def\titlerunning{Proposal}
\def\authorrunning{Anran Wang}
\title{\Large Necessary Liberal Preconditions \\\normalsize A Master Thesis Proposal}
\author{Anran Wang}
\maketitle

%\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\input{01introduction.tex}
\section{Background}\label{sec:background}

With computer programs melded into almost every aspect of human life, we often not only require their efficiency, but also their correctness. 
We would like to know for sure that our programs deliver the desired results, and do not run forever. 
This is called \textit{total correctness}. 
To know ``for sure'', we could verify programs using formal methods that have been developing for decades. 
One of such methods are \textit{Hoare Triples}~\cite{Hoare1969} proposed by Tony Hoare in 1969. 
A Hoare Triple contains three parts: a precondition, a program, and a postcondition. 
They are written as such: $\{F\}C\{G\}$.\footnote{Originally it was written as $F \{C\} G$, but now it is often written with brackets around conditions instead of the program.} 
It states that if the system is in a state that satisfies the precondition, then the state after the execution of the program will satisfy the postcondition, provided that the program terminates.
This is called \textit{partial correctness}. 

Originally, Hoare Triples only deals with deterministic programs in a top-to-down manner, but nondeterminism can be added in a sensible way like Dijkstra did in \cite{Dijkstra1975}. 
He presented the \textit{weakest precondition} transformer (wp): starting with a postcondition, it works backwards and ``guesses'' what the precondition can be. 
wp is concerned with total correctness and is related to Hoare Triples by an implication: 
\[\forall G.\ G\implies wp.C.F: \{G\} C \{F\}\] 
\footnote{Here $wp.C.F$ is a function written in lambda-calculus style, it can be seen now as a function $wp(C,F)$. This form of writing proves to be simple and elegant in the upcoming sections.}
This connection not only tells us that 
\begin{itemize}
    \item[-] given $wp.C.F$, any predicate $G$ that implies it can be the precondition of a valid Hoare Triple: $\{G\} C \{F\}$; 
\end{itemize}
it also shows when Hoare Triple will guarantee total correctness: 
\begin{itemize}
    \item[-] given a valid Hoare Triple $\{G\} C \{F\}$, if its precondition $G$ implies $wp.C.F$, then $\{G\} C \{F\}$ is valid for total correctness. 
\end{itemize}

Sometimes, however, we deem nontermination a good behaviour, and proving partial correctness suffices. 
The \textit{weakest liberal precondition} transformer \cite{Dijkstra1990} can be used in such occasions: 
if the system is in a state satisfying $wlp(C,F)$, then either $F$ is reachable after the termination of $C$, or $C$ does not terminate.
wlp directly relates to Hoare Triples via an implication: 
\[\forall G.\ G\implies wlp(C,F): \{G\} C \{F\}\]
$G$ is then called the \textit{sufficient liberal precondition}, and finding it means we can prove the absense of errors in the program (if it terminates). 
In contrast, the \textit{necessary liberal precondition} $G$ (where $ wlp(C,F)\implies G$) tells us that the system will not satisfy the postcondition $F$, once $G$ is violated. 
Cousot et al. studied the matter from a practical perspective~\cite{Cousot2013}, they proposed inference tools and experimented in industrial codes.
In this thesis, we aim to research this matter further with a more theoretical view. 
We would like to propose a proof system and prove its soundness and completeness similar as in \cite{Vries2011}, but using Dijkstra's guarded command language (GCL)~\cite{Dijkstra1975}. 

Instead of the usual qualitative reasoning using logical predicates, we would like to study in a quantitive setting using functions that represent quantities such as expectations of program variables. 
While predicates map program states to true or false, functions map program states to $\Rinf$, real numbers extended with (negative) infinity. 
In this setting, not only are infinities clear indication for nontermination, the transformers can also express more such as flow of quantitive information~\cite{Zhang2022}.


\section{Preliminaries}
\subsection{Quantitiy}
Let $\Sigma$ be the set of all program states, then the set of quantities is defined by 
\[A=\{f\mid f:\Sigma\to\Rinf\}\] 
With the ordering 
\[f\preceq g \text{ iff } \forall \sigma \in \Sigma: f(\sigma)\leq g(\sigma)\]
as well as join $\join$ and meet $\meet$
\[f\join g = \lambda \sigma.min\{f(\sigma), g(\sigma)\}; \ \ \  f\meet g = \lambda \sigma.max\{f(\sigma), g(\sigma) \}\]
we can define a complete lattice $\langle A, \preceq\rangle$. 
Note that all subsets in a complete lattice have supremum and infimum. 

Informally, $f\preceq g$ is analogous to $F\implies G$ for predicates, $\join$ ($\meet$) is analogous to $\wedge$ ($\vee$). 

\subsection{Hoare Triple}
A Hoare Triple is a triple $ \{G\} C \{F\}$ where $G$ and $F$ are logical predicates and C is a program. 
$G$ is called a \textit{precondition}, $F$ a \textit{postcondition}. 
This triple reads ``if $G$ is satisfied before the execution of $C$, then if $C$ terminates, $F$ is satisfied after the execution of $C$''. 

\subsection{Weakest (Liberal) Prequantity}
Let $\bkt C (\sigma)$ be the set of all \textbf{reachable} states by program $C$ from initial state $\sigma$, $f$ a \textit{postquantity}. 
Let $\bigmeet S$ denote the supremum of set $S$, then: 
\[wp.C.f.\sigma = \underset{\tau\in\bkt C(\sigma)}{\bigmeet} f(\tau)\]

As the name suggests, $wp.C.f.\sigma$ gives the ``weakest'', i.e. supremum, prequantity given post quantity $f$. 


\begin{comment}
We can now use some implications to define correctness or incorrectness as shown in \tab{impl}. 
\begin{table}\centering 
    \begin{tabular}{cc}
      \textbf{implication}&\textbf{defines}    \\ \hline
      $G\implies wp(C,F)$&   total correctness   \\
      $G\implies wlp(C,F)$&  partial correctness\\
      $wp(C,F)\implies G$&  partial incorrectness\\
      $wlp(C,F)\implies G$&  ???\\
    \end{tabular}
    \caption{implications using wp and wlp\cite{Zhang2022}}
    \label{tab:impl}
\end{table}    
\end{comment}

We are interested in the last implication labeled with ???, where $G$ is called the \textit{necessary liberal precondition}, in the sense that 
\begin{itemize}
    \item [-] all preconditions that leads to non-termination of $C$ imply $G$, 
    \item [-] a preconditions that does not imply $G$ leads to a postcondition that does not imply $F$. 
\end{itemize}
It is our goal to study this implication and its connection to correctness/incorrectness. 


\subsection{Guarded Command Language}
We use Dijkstra's (nondeterministic) guarded command language (nGCL)~\cite{Dijkstra1975} to conceptualize a computer program and to include nondeterminism. 
For better understanding, we use an equivalent form~\cite{Zhang2022} of nGCL that is similar to modern pseudo-code: 
$$C\ ::=\ \  x:= e \ \ \mid\ \  C;C \ \ \mid\ \  \{C\} \square \{C\} \ \ \mid\ \  
if\ (\varphi)\ \{C\}\ else\ \{C\} \ \ \mid\ \  while\ (\varphi)\ \{C\}$$

\section{A Proof System}
The goal of this thesis is to study the necessary liberal precondition and its relation to Hoare Triple. 
It would be beneficial to come up with a (complete and sound) proof system and apply it to important algorithms. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{eptcsini}
\bibliography{references}

\end{document}